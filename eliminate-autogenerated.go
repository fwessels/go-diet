package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	_ "reflect"
)

type EliminateAutogeneratedASTVisitor struct {
	scanCode  bool
	info      *types.Info
	funcName  string
	funcEnd   token.Pos
	recvNames map[string]string
	eligible  map[string]bool
	rejected  map[string]bool
}

func (eav *EliminateAutogeneratedASTVisitor) eligibleCount() int {
	return len(eav.eligible)
}

func eliminateAutogenerated(file *ast.File) (*ast.File, *EliminateAutogeneratedASTVisitor) {

	info := types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}

	scanner := &EliminateAutogeneratedASTVisitor{info: &info, scanCode: true, eligible: make(map[string]bool), rejected: make(map[string]bool)}
	ast.Walk(scanner, file)

	if *verbose {
		scanner.listVerbose()
	}

	fixer := &EliminateAutogeneratedASTVisitor{info: &info, scanCode: false, eligible: scanner.eligible}
	ast.Walk(fixer, file)

	return file, scanner
}

func (v *EliminateAutogeneratedASTVisitor) Visit(node ast.Node) ast.Visitor {
	if node != nil {
		if v.funcEnd > 0 && node.Pos() > v.funcEnd {
			v.funcName, v.funcEnd = "", 0
		}
		if !v.scanCode && v.funcName != "" && !v.eligible[v.funcName] {
			return v
		}
		//fmt.Printf("%d: %s\n", nr, reflect.TypeOf(node).String())
		switch n := node.(type) {
		case *ast.FuncDecl:

			if n.Body != nil {
				v.funcEnd = n.Body.Rbrace
				v.funcName = n.Name.Name
				v.recvNames = make(map[string]string)
			} else {
				v.funcName, v.funcEnd = "", 0
				v.recvNames = make(map[string]string)
			}

			if n.Recv != nil && len(n.Recv.List) > 0 {
				l := n.Recv.List[0]

				// Switch based on the type of receiver (value or pointer)
				switch t := l.Type.(type) {
				case *ast.Ident: // value receiver
					n.Recv.List[0].Type = &ast.StarExpr{Star: t.Pos(), X: &ast.Ident{Name: t.Name, NamePos: t.Pos() + 1}}

					v.recvNames[v.funcName] = l.Names[0].String()

					// Add this function as eligible
					v.eligible[v.funcName] = true

				case *ast.StarExpr: // pointer receiver
					// Skip this function
				}
			}

		case *ast.AssignStmt:
			// Check for either direct or indirect assignments to the receiver object
			// If any are found remove the function as eligible to change into a
			// pointer receiver as this will result in unexpected code changes
			if v.scanCode {
				for _, e := range n.Lhs {
					switch direct := e.(type) {
					case *ast.Ident: // direct assigment
						if direct.Name == v.recvNames[v.funcName] {
							v.markAsNotEligible(v.funcName)
						}
					case *ast.SelectorExpr: // indirect assignment via member
						switch outer := direct.X.(type) {
						case *ast.Ident:
							if outer.Name == v.recvNames[v.funcName] {
								v.markAsNotEligible(v.funcName)
							}
						}
					}
				}
			}
		}
	}
	return v
}

func (v *EliminateAutogeneratedASTVisitor) markAsNotEligible(name string) {
	// Mark this function as not eligible
	if _, found := v.eligible[name]; found {
		// Remove this function
		delete(v.eligible, name)
		v.rejected[name] = true
	}
}

func (v *EliminateAutogeneratedASTVisitor) listVerbose() {
	if len(v.eligible) == 0 {
		fmt.Println("No eligible functions.")
	} else {
		fmt.Println("Eligible functions:")
		for k, _ := range v.eligible {
			fmt.Printf("    - %s()\n", k)
		}
	}
	if len(v.rejected) > 0 {
		fmt.Println("Rejected functions:")
		for k, _ := range v.rejected {
			fmt.Printf("    - %s()\n", k)
		}
	}
}
