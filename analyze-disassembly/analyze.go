package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	_ "sort"
	"strconv"
	"strings"
	"text/tabwriter"
	_ "text/tabwriter"
)

// readLines reads a whole file into memory
// and returns a slice of its lines.
func readLines(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	return lines, scanner.Err()
}

var regexpGoroutine = regexp.MustCompile(`^TEXT\s(.*)\(SB\)\s(\<autogenerated\>)?`)

func analyzeFuncDisassembly(lines []string) {

	for _, l := range lines {
		fmt.Println(l)
		fmt.Println(strings.Fields(l))
	}
}

func splitSubroutine(subroutine string) (pkg, rcv, name string, pointerRcv bool) {

	// Hack for rcv with dot
	if strings.HasPrefix(subroutine, "net.(*dialResult.1)") ||
	strings.HasPrefix(subroutine, "net.(*racer.2)") {
		pkg = "net"
		if strings.HasPrefix(subroutine, "net.(*dialResult.1)") {
			rcv = "dialResult.1"
		} else {
			rcv = "racer.2"
		}
		name = subroutine[len(pkg)+1+len(rcv)+4:]
		pointerRcv = true
		return
	}

	slashes := strings.Split(subroutine, "/")

	parts := strings.Split(slashes[len(slashes)-1], ".")

	// Check for `..` and merge back for names such as glob..func1
	for i, p := range parts {
		if p == "" { // found an '..'
			if i+2 != len(parts) {
				panic("Expected '..' in penultimate position")
			}
			concat := strings.Join(parts[i-1:i+2], ".")
			parts = parts[:i-1]
			parts = append(parts, concat)
			break
		}
	}
	if len(parts) == 1 {
		name = parts[0]
	} else if len(parts) == 2 {
		pkg = parts[0]
		name = parts[1]
	} else if len(parts) <= 5 {
		pkg = parts[0]
		rcv = parts[1]
		name = strings.Join(parts[2:], ".")
	} else {
		panic("Unexpected number of parts")
	}

	if strings.Contains(name, ")") && !strings.Contains(name, "(") {
		i := 0 // Find opening brace
		for i = len(subroutine) - len(name); i >= 0; i-- {
			if subroutine[i:i+2] == ".(" {
				break
			}
		}
		name = subroutine[i+1:]
		// Find previous '.' separator for receiver
		for i = len(subroutine) - len(name) - 2; i >= 0; i-- {
			if subroutine[i] == '.' {
				break
			}
		}
		rcv = subroutine[i+1 : len(subroutine)-len(name)-1]
		// pkg is the rest
		pkg = subroutine[:len(subroutine)-(len(".")+len(rcv)+len(".")+len(name))]
	} else if len(slashes) > 1 {
		packagePath := strings.Join(slashes[:len(slashes)-1], "/")
		v := strings.Split(packagePath, "/vendor/")
		pkg = v[len(v)-1] + "/" + pkg
	}
	if rcv != "" {
		fmt.Println("package:", pkg, "receiver:", rcv, "name:", name)
	} else {
		fmt.Println("package:", pkg, "name:", name)
	}

	if strings.HasPrefix(rcv, "(*") && strings.HasSuffix(rcv, ")") {
		pointerRcv = true
		rcv = rcv[2 : len(rcv)-1]
	} else if strings.HasPrefix(rcv, "(") && strings.HasSuffix(rcv, ")") {
		// Wrapper in case of eg
		//	bucket.Methods("HEAD").Path("/{object:.+}").HandlerFunc(api.HeadObjectHandler)
		rcv = rcv[1 : len(rcv)-1]
	}
	return
}

func dumpPkgMap(pkgMap map[string]map[string][]Subroutine) {

	fmt.Println("=== P A C K A G E S ===")
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, '-', tabwriter.AlignRight|tabwriter.Debug)
	fmt.Fprintln(w, "package", "\t", "# funcs", "\t", "# autogend", "\t", "size")
	ranked := rankPackages(pkgMap)
	for _, pkg := range ranked {
		fmt.Fprintln(w, pkg.Name, "\t", pkg.Subroutines, "\t", pkg.Autogend, "\t", pkg.Size)
		//fmt.Fprintln(w, n, "\t", v.Subroutines, "\t", v.Size)
	}
	w.Flush()

	for k, v := range pkgMap {
		if k == "github.com/minio/minio/cmd" {
			dumpReceiverMap(k, v)
		}
	}
}

func getPackageSize(rcvMap map[string][]Subroutine) (total uint64) {

	for _, subs := range rcvMap {
		for _, s := range subs {
			total += s.size
		}
	}
	return
}

func dumpReceiverMap(pkg string, rcvMap map[string][]Subroutine) {

	fmt.Println("=== R E C E I V E R S ===")
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, '-', tabwriter.AlignRight|tabwriter.Debug)
	ranked := rankReceivers(rcvMap)
	total, funcs, autogend := uint64(0), 0, 0
	for _, v := range ranked {
		total += v.Size
		funcs += v.Subroutines
		autogend += v.Autogend
	}
	fmt.Fprintln(w, "receiver", "\t", "# funcs", "\t", "# autogend", "\t", "size")
	fmt.Fprintln(w, pkg, "\t", funcs, "\t", autogend, "\t", total)
	fmt.Fprintln(w, "", "\t", "", "\t", "", "\t", "")
	for _, v := range ranked {
		n := v.Name
		if n == "" {
			n = "(global)"
		}
		fmt.Fprintln(w, n, "\t", v.Subroutines, "\t", v.Autogend, "\t", v.Size)
	}
	w.Flush()
}

type Subroutine struct {
	name       string
	size       uint64
	autogend   bool
	pointerRcv bool
}

type PackageMap map[string]map[string][]Subroutine

func parseDisassembly(lines []string) (pkgMap PackageMap) {

	subroutine, autogend, addr, isub := "", false, uint64(0), 0

	pkgMap = make(PackageMap)

	const skipFirstLines = 1 * 1256
	for index, line := range lines {
		if match := regexpGoroutine.FindStringSubmatch(line); len(match) > 0 {
			hex := strings.Fields(lines[index+1])[1]

			s, err := strconv.ParseUint(hex[2:], 16, 64)
			if err != nil {
				panic("Failed to convert hex number")
			}
			if addr != 0 {
				if strings.HasPrefix(subroutine, "type..") {

				} else if strings.HasPrefix(subroutine, "go.(*struct") {

				} else if strings.HasPrefix(subroutine, "go.struct {") {

				} else {
					isub++
					if isub >= skipFirstLines {
						fmt.Println(subroutine, s-addr)
						pkg, rcv, name, pointerRcv := splitSubroutine(subroutine)

						_, pkgExists := pkgMap[pkg]
						if !pkgExists {
							pkgMap[pkg] = make(map[string][]Subroutine)
						}
						_, rcvExists := pkgMap[pkg][rcv]
						if !rcvExists {
							pkgMap[pkg][rcv] = make([]Subroutine, 0)
						}
						pkgMap[pkg][rcv] = append(pkgMap[pkg][rcv], Subroutine{name: name, size: s - addr, pointerRcv: pointerRcv, autogend: autogend})
					}
					if isub == 1260+15250 {
						return
					}
				}
			}
			subroutine, autogend, addr = match[1], match[2] == "<autogenerated>", s
		}
	}

	return
}

func main() {

	lines, _ := readLines("minio.dis")

	pkgMap := parseDisassembly(lines)

	dumpPkgMap(pkgMap) //fmt.Println(pkgMap)

}
